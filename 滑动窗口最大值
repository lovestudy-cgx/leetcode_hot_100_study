首先需要有初始化的概念，无论是做窗口，然后微调，这一步代码得会
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        # 注意 Python 默认的优先队列是小根堆，而本题是大根堆，因此取个相反值
        q = [(-nums[i], i) for i in range(k)]
        heapq.heapify(q)

        ans = [-q[0][0]]
        for i in range(k, n):#定义窗口的右端点
            heapq.heappush(q, (-nums[i], i))
            while q[0][1] <= i - k:#如果该元素在窗口左边，就去掉
                heapq.heappop(q)
            ans.append(-q[0][0])#因为处理之后的最左边就是堆的最小值（也就是原来列表的最大值）
        
        return ans

heapq 是 Python 自带的一个 堆队列（优先队列）算法模块，底层使用的是一个 最小堆（小根堆）。

**最小堆（min-heap）**的定义是：每个节点的值都小于或等于其子节点的值。

堆结构可以用一个普通的 list 表示，heapq 操作的就是这个 list。

它不是一个类，而是一组函数（对 list 操作）。

🔧 heapq 提供的核心函数：
函数	作用
heapq.heapify(lst)	将一个列表原地转化为一个堆（最小堆）结构
heapq.heappush(heap, item)	向堆中加入一个元素，并保持堆结构
heapq.heappop(heap)	弹出并返回堆中最小的元素
heapq.heappushpop(heap, item)	将 item 加入堆中后再 pop 最小值，效率高于分开执行
heapq.nlargest(n, iterable)	返回 iterable 中最大的 n 个元素
heapq.nsmallest(n, iterable)	返回最小的 n 个元素


class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        q = collections.deque()
        for i in range(k):
            while q and nums[i] >= nums[q[-1]]:
                q.pop()
            q.append(i)

        ans = [nums[q[0]]]
        for i in range(k, n):
            while q and nums[i] >= nums[q[-1]]:
                q.pop()
            q.append(i)
            while q[0] <= i - k:
                q.popleft()
            ans.append(nums[q[0]])
        
        return ans

这一方法是按照队列来写的，核心也是先创建队列，然后ans存储最大值，deque存储序号，不同的是，这个里面的while会判断我准备传入的q和之前存放的所有值比较，如果他大，就把之前所有数删掉。第二个while判断是否做窗口越界，其实我觉得这一种更符合惯性思维，
而且没有用到那种专门的堆的函数。
细节：while q：q非空的时候才能执行。本题设置deque因为便于删除元素o1，list是on
